//this file is generated by codedump at ${G.DATETIME} do NOT edit it !

#include "${Meta.FileName}.h"


bool ${Meta.Name}Parser::Initialize(const char* file)
{
	Init(this);
	return Register(file, &${Meta.Name}Parser::LoadConfig);
}

bool ${Meta.Name}Parser::LoadConfig(nlohmann::json& root, bool init)
{
    try
    {
        return Parse${Meta.RootClassName}(root, m_config);
    }
    catch(nlohmann::detail::exception ex)
    {
     	LogError("${Meta.Name}Parser::LoadConfig error: ", ex.what());
		lightAssert(false && "${Meta.Name}Parser::LoadConfig error ");
		return false;   
    }
}

@{FOREACH(Class IN ${Meta.ClassList})}
bool ${Meta.Name}Parser::Parse${Class.Name}(nlohmann::json& root, ${Class.Name}& info)
{
@{FOREACH(Field IN ${Class.FieldList})}
@{SWITCH(${Field.MetaType})}
@{CASE(class)}
    {
        auto& v_class = root["${Field.Tag}"];
        if(!Parse${Field.Type}(v_class, info.${Field.Name}))
        {
            return false;
        }
    }
@{CASE(dict_class)}
    {
        auto& v_dict = root["${Field.Tag}"];
        for(auto it=v_dict.begin(); it!=v_dict.end(); ++it)
        {
            ${Field.DictValueType} element;
            if(!Parse${Field.DictValueType}(*it, element))
            {
                return false;
            }
            info.${Field.Name}.emplace(element.${Field.DictKeyName}, element);
        }
    }
@{CASE(list_class)}
    {
        auto& v_list = root["${Field.Tag}"];

        for(auto it=v_list.begin(); it!=v_list.end(); ++it)
        {
            ${Field.ListValueType} element;
            if(!Parse${Field.ListValueType}(*it, element))
            {
                return false;
            }
            info.${Field.Name}.push_back(element);
            
        }
    }
@{CASE(bool||string||int||float||list_basic||dict_basic)}
    if(!root["${Field.Tag}"].is_null())
    {
        info.${Field.Name} = root["${Field.Tag}"].get<${Field.Type}>();
    }
@{END_SWITCH}
@{END_FOREACH}

    return true;
}

@{END_FOREACH}


