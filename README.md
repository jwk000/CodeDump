# CodeDump 一种通用的代码生成方案


## 概述
一种通过数据结构描述文件（meta文件）和目标代码模板文件（template文件）生成目标代码的方案。基本思路是先解析meta文件得到数据结构信息，然后解析template文件得到目标代码的规则信息，对template文件展开，填充meta信息，就得到了目标代码。

## CodeDump工具使用说明
遍历目录生成代码：

usage1: CodeDump --xmldir=test/xml/ --lang=.h;.cpp;.cs --tpldir=template/ --tardir=test/dumpcode/

单个文件生成代码：

usage2: CodeDump --idl=xxx.idl --lang=cpp;cs  --tpldir=template/ --tardir=test/dumpcode/



参数说明：

xmldir idl文件存放目录

lang 生成代码的语言，目前只有.cs、.cpp、.h三种

tpldir 模板文件目录

tardir 生成代码文件目录



必需的配置文件是template/目标代码模板、xml文件的idl描述文件。

注意生成代码的时候要先check out可能被Overwrite的代码文件。

以xml解析生成C#代码为例介绍使用规则。这里使用anniversary_campaign.xml。
```xml
<?xml version="1.0" encoding="utf-8"?>
<Config>
    <!-- 活动id 嘉年华加成活动id -->
    <Misc campaign_id="24001" carnival_activity="24001" />
    <Seat>
        <!--杂项 ABC级座椅ID-->
        <Misc seat_a_id="10400009" seat_b_id="10400010" seat_c_id="10400011" />
        <Upgrades>
            <!--座椅升级配置，座椅id，升级材料，下级座椅id-->
            <Upgrade seat_id="10400009" next_seat_id="10400010">
                <Need type="item" boy_id="920000160" girl_id="920000160" num="300" />
            </Upgrade>
            <Upgrade seat_id="10400010" next_seat_id="10400011">
                <Need type="item" boy_id="920000160" girl_id="920000160" num="600" />
            </Upgrade>
        </Upgrades>
    </Seat>
    <Signin>
        <!--签到送布衣：累计天数-->
        <Day dayid="1">
            <Reward type="gb" boy_id="0" girl_id="0" num="100" />
        </Day>
        <Day dayid="2">
            <Reward type="gb" boy_id="0" girl_id="0" num="200" />
        </Day>
        <Day dayid="3">
            <Reward type="gb" boy_id="0" girl_id="0" num="300" />
        </Day>
        <Day dayid="4">
            <Reward type="gb" boy_id="0" girl_id="0" num="400" />
        </Day>
        <Day dayid="5">
            <Reward type="gb" boy_id="0" girl_id="0" num="500" />
        </Day>
        <Day dayid="6">
            <Reward type="gb" boy_id="0" girl_id="0" num="600" />
        </Day>
        <Day dayid="7">
            <Reward type="gb" boy_id="0" girl_id="0" num="700" />
        </Day>
        <Day dayid="8">
            <Reward type="gb" boy_id="0" girl_id="0" num="800" />
        </Day>
        <Day dayid="9">
            <Reward type="gb" boy_id="0" girl_id="0" num="900" />
        </Day>
        <Day dayid="10">
            <Reward type="gb" boy_id="0" girl_id="0" num="1000" />
        </Day>
    </Sigin>
    <Passport>
        <Share>
            <Reward type="gb" boy_id="0" girl_id="0" num="1000" />
        </Share>
        <Triggers>
            <Trigger id="2300031" />
            <Trigger id="2300032" />
            <Trigger id="2300033" />
            <Trigger id="2300034" />
            <Trigger id="2300035" />
        </Triggers>
    </Passport>
</Config>
```

### 1.	填写xml对应的IDL文件

anniversary_campaign.xml.idl
```C#
class RewardInfo{
 int type;
 int boy_id;
 int girl_id;
 int num;
}
class SeatNeed{
 [reward]
 RewardInfo need;
}
class AnnyMisc{
 int campaign_id;
 int carnival_activity;
}
class SeatMisc{
 int seat_a_id;
 int seat_b_id;
 int seat_c_id;
}
 
 
class SeatUpgrade{
 int seat_id;
 int next_seat_id;
 [Need]
 SeatNeed need;
}
class Seat{
 [tag(Misc)]
 SeatMisc misc;
 [tag(Upgrades)]
 List<SeatUpgrade> upgrade;
}
class Day{
 [key]
 int dayid;
 [reward]
 RewardInfo reward;
}
[root]
class AnniversaryConfig
{
 [tag(Misc)]
 AnnyMisc misc;
 Seat seat;
 [tag(Signin)]
 Dict<int,Day> signin_cfg;
}
```

说明：

- 采用类似C#语法的规则，Dictionary比较长，简写成了Dict，目前支持类（class）、枚举（enum）、基本数据类型、容器（只支持List和Dict）、特性（attribute）、注释、默认值、引用（using）。
- 特性是为了辅助生成代码使用的，比如[key]标记的字段是类的key字段，用于解析Dict的时候找到key的名字。
- [string]表示这个字段从xml节点的一个属性字符串解析，而不是从一个xml节点解析。
- [reward]表示这个字段是用reward专用读取函数读取的。
- [root]表示这个类是配置文件的根类型，在生成C++代码时需要知道根类型。
- Using引用的meta文件会在C++中解析为#include 头文件。

### 2.	填写目标代码template文件

template_parser.h

 ```
 //this file is generated by codedump tool at ${META_DATETIME} do NOT edit it !
 
 
#ifndef __${META_NAME}__PARSER_H__
#define __${META_NAME}__PARSER_H__
#include <map>
#include <vector>
#include <string>
#include <platform/platform_shared/dynamic_config.h>
 
@{BEGIN_ENUM}
${ENUM_COMMENT}
enum ${ENUM_NAME}
{
@{BEGIN_ENUM_FIELD}
    ${ENUM_FIELD_NAME} = ${ENUM_FIELD_VALUE}, ${ENUM_FIELD_COMMENT}
@{END_ENUM_FIELD}
};
 
@{END_ENUM}
 
@{BEGIN_CLASS}
${CLASS_COMMENT}
struct ${CLASS_NAME}
{
@{BEGIN_CLASS_FIELD}
    ${CLASS_FIELD_TYPE} ${CLASS_FIELD_NAME}; ${CLASS_FIELD_COMMENT}
@{END_CLASS_FIELD}
};
 
@{END_CLASS}
 
class ${META_NAME}Parser: public CDynamicConfig
{
public:
    bool Init(const char* xmlfile);
    virtual bool LoadConfig(variant* root);
    const ${META_ROOT_CLASS_NAME}& GetConfig(){return m_config;}
@{BEGIN_CLASS}
    bool Parse${CLASS_NAME}(variant* root, ${CLASS_NAME}& info);
@{END_CLASS}
private:
    ${META_ROOT_CLASS_NAME} m_config;
};
 
#endif //__${META_NAME}__PARSER_H__
```
 
说明：
这是生成C#代码的模板文件，其基本规则如下：

- `@{\w+}` 为“规则标记”，通常成对出现，@{BEGIN_XXX} @{END_XXX}，用来指示中间的文本展开规则。规则的分类和数据结构有关，从meta级别到text级别处理方式不同。
- `${\w+}` 为“数据标记”，数据处理和规则对应，每个级别的规则都有相应级别的数据，比如${META_NAME}表示meta级别的名称，${CLASS_FIELD_NAME}为类字段级别名称。

目前支持的规则标记
```C#
enum eTemplateRule
{
    PLAIN_TEXT,//没有规则
    META_TEXT,//对所有line应用meta替换
    META,//对所有meta应用规则
    USING,//对所有using应用规则
    ENUM,//对所有enum应用规则
    ENUM_FIELD,//对所有enum field应用规则
    CLASS,//对所有class应用规则
    CLASS_ATTR_STRING,//对带有string特性的class应用规则
    CLASS_FIELD,//对所有class field应用规则
    //switch case
    CLASS_FIELD_TYPE_DICT,//根据不同类型选用规则
    CLASS_FIELD_TYPE_LIST,//字段类型为List<class>时使用此规则
    CLASS_FIELD_TYPE_LIST_BASIC,//字段类型为List<基本类型>时使用此规则
    CLASS_FIELD_TYPE_CLASS,//字段类型为class时使用此规则
    CLASS_FIELD_TYPE_DICT_STRING,
    CLASS_FIELD_TYPE_LIST_STRING,
    CLASS_FIELD_TYPE_CLASS_STRING,
    CLASS_FIELD_TYPE_ENUM,
    CLASS_FIELD_TYPE_STRING,
    CLASS_FIELD_TYPE_INT,
    CLASS_FIELD_TYPE_FLOAT,
    CLASS_FIELD_TYPE_BOOL,
    CLASS_FIELD_TYPE_BASIC,//int float bool string
    //if else
    IF,
    IF0,
    IF1,
    IF2,
    SWITCH,
}
    }
```

目前支持的数据标记
```C#
enum eTemplateData
{
    META_DATETIME, //得到当前时间
    META_NAME, //meta名称
    META_HAS_ROOT,//meta是否有root
    META_FILE_NAME,//meta文件名
    META_FILE_PATH, //meta文件路径
    META_ROOT_CLASS_NAME, //根类型名称
 
    USING_COMMENT, //引用的注释
    USING_META_NAME, //引用meta的名称
 
    CLASS_COMMENT, //类的注释
    CLASS_NAME, //类型名称
    CLASS_TAG_NAME,//类的xml标签名称
    CLASS_ATTR_NAME,//类特性名称
    CLASS_ATTR_PARAM,//类特性参数
    CLASS_KEY_NAME, //类的key名称
 
    CLASS_FIELD_COMMENT, //类字段注释
    CLASS_FIELD_NAME,//类字段名称
    CLASS_FIELD_TYPE, //类字段类型
    CLASS_FIELD_TAG,//类字段xml标签名称
    CLASS_FIELD_KEY, //类字段类的key名称
    CLASS_FIELD_DEFAULT_VALUE, //类字段默认值
    CLASS_FIELD_IS_OPTIONAL,//是否可选字段
    CLASS_FIELD_ATTR_NAME,//特性
    CLASS_FIELD_ATTR_PARAM,//特性参数
    CLASS_FIELD_INDEX,//字段序号
 
    LIST_VALUE_TYPE, //list类型的value类型
    LIST_VALUE_TAG,//list的value的xml标签
 
    DICT_KEY_TYPE, //dict类型的key类型
    DICT_VALUE_TYPE, //dict类型的value类型
    DICT_VALUE_TAG,//dict的value的xml标签
 
    ENUM_NAME, //枚举名称
    ENUM_COMMENT,//枚举注释
 
    ENUM_FIELD_NAME, //枚举字段名称
    ENUM_FIELD_VALUE, //枚举字段值
    ENUM_FIELD_COMMENT, //枚举字段注释
 
    MaxCount
}
```

### 3.	使用CodeDump工具生成代码
本例中生成的C++代码为anniversary_campaign_parser.h
```
//this file is generated by codedump tool at 1/14/2019 20:16:15 do NOT edit it !
 
 
#ifndef __AnniversaryCampaign__PARSER_H__
#define __AnniversaryCampaign__PARSER_H__
#include <map>
#include <vector>
#include <string>
#include <platform/platform_shared/dynamic_config.h>
 
 
 
struct RewardInfo
{
    int type;
    int boy_id;
    int girl_id;
    int num;
};
 
 
struct SeatNeed
{
    RewardInfo need;
};
 
 
struct AnnyMisc
{
    int campaign_id;
    int carnival_activity;
};
 
 
struct SeatMisc
{
    int seat_a_id;
    int seat_b_id;
    int seat_c_id;
};
 
 
struct SeatUpgrade
{
    int seat_id;
    int next_seat_id;
    SeatNeed need;
};
 
 
struct Seat
{
    SeatMisc misc;
    std::vector<SeatUpgrade> upgrade;
};
 
 
struct Day
{
    int dayid;
    RewardInfo reward;
};
 
 
struct AnniversaryConfig
{
    AnnyMisc misc;
    Seat seat;
    std::map<int,Day> signin_cfg;
};
 
 
class AnniversaryCampaignParser: public CDynamicConfig
{
public:
    bool Init(const char* xmlfile);
    virtual bool LoadConfig(variant* root);
    const AnniversaryConfig& GetConfig(){return m_config;}
    bool ParseRewardInfo(variant* root, RewardInfo& info);
    bool ParseSeatNeed(variant* root, SeatNeed& info);
    bool ParseAnnyMisc(variant* root, AnnyMisc& info);
    bool ParseSeatMisc(variant* root, SeatMisc& info);
    bool ParseSeatUpgrade(variant* root, SeatUpgrade& info);
    bool ParseSeat(variant* root, Seat& info);
    bool ParseDay(variant* root, Day& info);
    bool ParseAnniversaryConfig(variant* root, AnniversaryConfig& info);
private:
    AnniversaryConfig m_config;
};
 
#endif //__AnniversaryCampaign__PARSER_H__
```

## IDL填写规范
1. 文件名中的template会转换为meta名
2.	目前支持类（class）、枚举（enum）、基本数据类型（int,bool,string,float）、容器（只支持List和Dict）、特性（attribute）、注释、默认值、引用（using）。
3.	需要指定xml的root节点对应的类为[root]。
4.	需要指定dict<k,v>的v类中作为key的字段为[key]。
5.	不存在Dict<int,int>这种配置。存在List<int>配置。
6.	[string]表示这个字段（class/list）从”1,2,3;4,5,6”这种字符串解析。不指定的话默认从下级节点解析。字符串分隔符是comma(,)和simicolon(;)
7.	[string]还可以修饰类，默认类从xml节点解析，添加此特性则允许其从string解析。需要配合以[string]修饰的字段使用。
8.	类型有依赖关系，所以被依赖的class要写在前面，如果引用了其他idl文件里的类型需要在文件开始的地方引用一下比如：using common_meta。

## Xml填写规范
1.	尽量不要混搭风格！节点尽量写完整！
2.	每个具名节点，在IDL中填写为class、List、Dict。Class的成员对应xml中的属性。举例：

![](https://github.com/jwk000/CodeDump/blob/master/doc/6.gif)
![](https://github.com/jwk000/CodeDump/blob/master/doc/7.gif)

3.	Class、dict、list成员如果为普通类型，也可以用inner_text的配置方式。
例子一：

![](https://github.com/jwk000/CodeDump/blob/master/doc/8.gif)
![](https://github.com/jwk000/CodeDump/blob/master/doc/9.gif)

例子二：

![](https://github.com/jwk000/CodeDump/blob/master/doc/10.gif)
![](https://github.com/jwk000/CodeDump/blob/master/doc/11.gif)

4.	可以省略dict和list的中间节点。
标准写法：

![](https://github.com/jwk000/CodeDump/blob/master/doc/12.gif)

省略写法：

![](https://github.com/jwk000/CodeDump/blob/master/doc/13.gif)

对应idl类：

![](https://github.com/jwk000/CodeDump/blob/master/doc/14.gif)

5.	不支持的配置方式：
例子一：既有attribute又有inner text，说明tip节点是个类，但丢失了一种字段描述。

![](https://github.com/jwk000/CodeDump/blob/master/doc/15.gif)

例子二：不确定的配置格式，根据需求扩展节点。这种情况只能拆表，根据道具类型拆分。否则就要在idl中定义所有类型，结果会非常冗余。

![](https://github.com/jwk000/CodeDump/blob/master/doc/16.gif)
![](https://github.com/jwk000/CodeDump/blob/master/doc/17.gif)

例子三：不支持复杂嵌套类从string解析。混搭格式也不支持。

![](https://github.com/jwk000/CodeDump/blob/master/doc/18.gif)

