//this file is generated by xml2code tool 7/19/2018 17:04:32
//DO NOT EDIT IT !

using System;
using System.Text;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using GYGeneric;

namespace GYXMLData
{

    //消耗物品的配置格式
    public class CostItem :IXmlParser
    {
        public int type =0; 
        public int id =0; 
        public int count =0; 

        public bool Parse(XmlNode node)
        {
            if(node.Attributes!=null && node.Attributes["type"]!=null)
            {
                type = int.Parse(node.Attributes["type"].Value);
            }
            else
            {
                var child = node.SelectSingleNode("type");
                if(child!=null)
                {
                    type = int.Parse(child.InnerText);
                }
            }
            if(node.Attributes!=null && node.Attributes["id"]!=null)
            {
                id = int.Parse(node.Attributes["id"].Value);
            }
            else
            {
                var child = node.SelectSingleNode("id");
                if(child!=null)
                {
                    id = int.Parse(child.InnerText);
                }
            }
            if(node.Attributes!=null && node.Attributes["count"]!=null)
            {
                count = int.Parse(node.Attributes["count"].Value);
            }
            else
            {
                var child = node.SelectSingleNode("count");
                if(child!=null)
                {
                    count = int.Parse(child.InnerText);
                }
            }

            return true;
        }
    }

    //奖励
    public class Reward :IXmlParser
    {
        public int type =0; 
        public int id =0; 
        public int count =0; 

        public bool Parse(XmlNode node)
        {
            if(node.Attributes!=null && node.Attributes["type"]!=null)
            {
                type = int.Parse(node.Attributes["type"].Value);
            }
            else
            {
                var child = node.SelectSingleNode("type");
                if(child!=null)
                {
                    type = int.Parse(child.InnerText);
                }
            }
            if(node.Attributes!=null && node.Attributes["id"]!=null)
            {
                id = int.Parse(node.Attributes["id"].Value);
            }
            else
            {
                var child = node.SelectSingleNode("id");
                if(child!=null)
                {
                    id = int.Parse(child.InnerText);
                }
            }
            if(node.Attributes!=null && node.Attributes["count"]!=null)
            {
                count = int.Parse(node.Attributes["count"].Value);
            }
            else
            {
                var child = node.SelectSingleNode("count");
                if(child!=null)
                {
                    count = int.Parse(child.InnerText);
                }
            }

            return true;
        }
    }

    //场景对象布局结构
    public class ObjectLayout :IXmlParser
    {
        public int id =0; 
        public int x =0; 
        public int y =0; 
        public int angle =0; 

        public bool Parse(XmlNode node)
        {
            if(node.Attributes!=null && node.Attributes["id"]!=null)
            {
                id = int.Parse(node.Attributes["id"].Value);
            }
            else
            {
                var child = node.SelectSingleNode("id");
                if(child!=null)
                {
                    id = int.Parse(child.InnerText);
                }
            }
            if(node.Attributes!=null && node.Attributes["x"]!=null)
            {
                x = int.Parse(node.Attributes["x"].Value);
            }
            else
            {
                var child = node.SelectSingleNode("x");
                if(child!=null)
                {
                    x = int.Parse(child.InnerText);
                }
            }
            if(node.Attributes!=null && node.Attributes["y"]!=null)
            {
                y = int.Parse(node.Attributes["y"].Value);
            }
            else
            {
                var child = node.SelectSingleNode("y");
                if(child!=null)
                {
                    y = int.Parse(child.InnerText);
                }
            }
            if(node.Attributes!=null && node.Attributes["angle"]!=null)
            {
                angle = int.Parse(node.Attributes["angle"].Value);
            }
            else
            {
                var child = node.SelectSingleNode("angle");
                if(child!=null)
                {
                    angle = int.Parse(child.InnerText);
                }
            }

            return true;
        }
    }

    
    public class bodyPart :IXmlParser
    {
        public int type = 0; 
        public int src = 0; 

        public bool Parse(XmlNode node)
        {
            if(node.Attributes!=null && node.Attributes["type"]!=null)
            {
                type = int.Parse(node.Attributes["type"].Value);
            }
            else
            {
                var child = node.SelectSingleNode("type");
                if(child!=null)
                {
                    type = int.Parse(child.InnerText);
                }
            }
            if(node.Attributes!=null && node.Attributes["src"]!=null)
            {
                src = int.Parse(node.Attributes["src"].Value);
            }
            else
            {
                var child = node.SelectSingleNode("src");
                if(child!=null)
                {
                    src = int.Parse(child.InnerText);
                }
            }

            return true;
        }
    }

    
    public class Pos :IXmlParser
    {
        public int x = 0; 
        public int y = 0; 

        public bool Parse(XmlNode node)
        {
            if(node.Attributes!=null && node.Attributes["x"]!=null)
            {
                x = int.Parse(node.Attributes["x"].Value);
            }
            else
            {
                var child = node.SelectSingleNode("x");
                if(child!=null)
                {
                    x = int.Parse(child.InnerText);
                }
            }
            if(node.Attributes!=null && node.Attributes["y"]!=null)
            {
                y = int.Parse(node.Attributes["y"].Value);
            }
            else
            {
                var child = node.SelectSingleNode("y");
                if(child!=null)
                {
                    y = int.Parse(child.InnerText);
                }
            }

            return true;
        }
    }

    
    public class Size :IXmlParser
    {
        public int w = 0; 
        public int h = 0; 

        public bool Parse(XmlNode node)
        {
            if(node.Attributes!=null && node.Attributes["w"]!=null)
            {
                w = int.Parse(node.Attributes["w"].Value);
            }
            else
            {
                var child = node.SelectSingleNode("w");
                if(child!=null)
                {
                    w = int.Parse(child.InnerText);
                }
            }
            if(node.Attributes!=null && node.Attributes["h"]!=null)
            {
                h = int.Parse(node.Attributes["h"].Value);
            }
            else
            {
                var child = node.SelectSingleNode("h");
                if(child!=null)
                {
                    h = int.Parse(child.InnerText);
                }
            }

            return true;
        }
    }


}
